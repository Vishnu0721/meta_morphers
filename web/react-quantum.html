<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Quantum Bloch Visualizer - React + Three.js</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
        .quantum-container { min-height: 100vh; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); }
        .bloch-sphere { background: rgba(31, 41, 55, 0.8); border: 1px solid rgba(59, 130, 246, 0.5); }
        .input-field { background: rgba(55, 65, 81, 0.8); border: 1px solid rgba(75, 85, 99, 0.8); }
        .input-field:focus { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .btn-primary { background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); }
        .btn-primary:hover { background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%); transform: translateY(-1px); }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        // Quantum Bloch Visualizer Component
        const QuantumVisualizer = () => {
            const [numQubits, setNumQubits] = React.useState(1);
            const [circuitInput, setCircuitInput] = React.useState('H 0');
            const [blochVectors, setBlochVectors] = React.useState([]);
            const [errorMessage, setErrorMessage] = React.useState('');
            const [loading, setLoading] = React.useState(false);

            // Complex number class
            class CustomComplex {
                constructor(re = 0, im = 0) {
                    this.re = re;
                    this.im = im;
                }

                add(other) {
                    return new CustomComplex(this.re + other.re, this.im + other.im);
                }

                sub(other) {
                    return new CustomComplex(this.re - other.re, this.im - other.im);
                }

                mul(other) {
                    return new CustomComplex(
                        this.re * other.re - this.im * other.im,
                        this.re * other.im + this.im * other.re
                    );
                }

                conj() {
                    return new CustomComplex(this.re, -this.im);
                }

                abs() {
                    return Math.sqrt(this.re * this.re + this.im * this.im);
                }
            }

            // Matrix operations
            const identityMatrix = (size) => {
                const mat = Array(size).fill(0).map(() => Array(size).fill(0).map(() => new CustomComplex(0, 0)));
                for (let i = 0; i < size; i++) {
                    mat[i][i] = new CustomComplex(1, 0);
                }
                return mat;
            };

            const kroneckerProduct = (matA, matB) => {
                const rowsA = matA.length;
                const colsA = matA[0].length;
                const rowsB = matB.length;
                const colsB = matB[0].length;

                const resultRows = rowsA * rowsB;
                const resultCols = colsA * colsB;
                const result = Array(resultRows).fill(0).map(() => Array(resultCols).fill(0).map(() => new CustomComplex(0, 0)));

                for (let i = 0; i < rowsA; i++) {
                    for (let j = 0; j < colsA; j++) {
                        for (let k = 0; k < rowsB; k++) {
                            for (let l = 0; l < colsB; l++) {
                                result[i * rowsB + k][j * colsB + l] = matA[i][j].mul(matB[k][l]);
                            }
                        }
                    }
                }
                return result;
            };

            const matrixVectorMultiply = (matrix, vector) => {
                const rows = matrix.length;
                const cols = matrix[0].length;
                if (cols !== vector.length) {
                    throw new Error("Matrix columns must match vector rows for multiplication.");
                }

                const result = Array(rows).fill(0).map(() => new CustomComplex(0, 0));
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        result[i] = result[i].add(matrix[i][j].mul(vector[j]));
                    }
                }
                return result;
            };

            const outerProduct = (vecA, vecB) => {
                const size = vecA.length;
                const result = Array(size).fill(0).map(() => Array(size).fill(0).map(() => new CustomComplex(0, 0)));
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        result[i][j] = vecA[i].mul(vecB[j].conj());
                    }
                }
                return result;
            };

            // Quantum gates
            const H = [
                [new CustomComplex(1 / Math.sqrt(2), 0), new CustomComplex(1 / Math.sqrt(2), 0)],
                [new CustomComplex(1 / Math.sqrt(2), 0), new CustomComplex(-1 / Math.sqrt(2), 0)],
            ];

            const X = [
                [new CustomComplex(0, 0), new CustomComplex(1, 0)],
                [new CustomComplex(1, 0), new CustomComplex(0, 0)],
            ];

            const Y = [
                [new CustomComplex(0, 0), new CustomComplex(0, -1)],
                [new CustomComplex(0, 1), new CustomComplex(0, 0)],
            ];

            const Z = [
                [new CustomComplex(1, 0), new CustomComplex(0, 0)],
                [new CustomComplex(0, 0), new CustomComplex(-1, 0)],
            ];

            const Rx = (theta) => [
                [new CustomComplex(Math.cos(theta / 2), 0), new CustomComplex(0, -Math.sin(theta / 2))],
                [new CustomComplex(0, -Math.sin(theta / 2)), new CustomComplex(Math.cos(theta / 2), 0)],
            ];

            const Ry = (theta) => [
                [new CustomComplex(Math.cos(theta / 2), 0), new CustomComplex(-Math.sin(theta / 2), 0)],
                [new CustomComplex(Math.sin(theta / 2), 0), new CustomComplex(Math.cos(theta / 2), 0)],
            ];

            const Rz = (theta) => [
                [new CustomComplex(Math.cos(theta / 2), -Math.sin(theta / 2)), new CustomComplex(0, 0)],
                [new CustomComplex(0, 0), new CustomComplex(Math.cos(theta / 2), Math.sin(theta / 2))],
            ];

            // Circuit simulation
            const simulateCircuit = (numQubits, operations) => {
                if (numQubits <= 0) return null;

                let stateVector = Array(2 ** numQubits).fill(0).map(() => new CustomComplex(0, 0));
                stateVector[0] = new CustomComplex(1, 0);

                const errors = [];

                for (const op of operations) {
                    try {
                        const parts = op.trim().split(/\s+/);
                        const gateName = parts[0].toUpperCase();
                        const qubits = parts.slice(1).map(Number);

                        if (qubits.some(q => q < 0 || q >= numQubits)) {
                            errors.push(`Error: Qubit index out of bounds for operation: ${op}`);
                            continue;
                        }

                        let gateMatrix;
                        if (gateName === 'H') {
                            gateMatrix = getFullGateMatrix(H, numQubits, qubits[0]);
                        } else if (gateName === 'X') {
                            gateMatrix = getFullGateMatrix(X, numQubits, qubits[0]);
                        } else if (gateName === 'Y') {
                            gateMatrix = getFullGateMatrix(Y, numQubits, qubits[0]);
                        } else if (gateName === 'Z') {
                            gateMatrix = getFullGateMatrix(Z, numQubits, qubits[0]);
                        } else if (gateName === 'RX') {
                            const angle = parseFloat(parts[1]);
                            if (isNaN(angle)) throw new Error('Invalid angle for Rx gate.');
                            gateMatrix = getFullGateMatrix(Rx(angle), numQubits, qubits[1]);
                        } else if (gateName === 'RY') {
                            const angle = parseFloat(parts[1]);
                            if (isNaN(angle)) throw new Error('Invalid angle for Ry gate.');
                            gateMatrix = getFullGateMatrix(Ry(angle), numQubits, qubits[1]);
                        } else if (gateName === 'RZ') {
                            const angle = parseFloat(parts[1]);
                            if (isNaN(angle)) throw new Error('Invalid angle for Rz gate.');
                            gateMatrix = getFullGateMatrix(Rz(angle), numQubits, qubits[1]);
                        } else if (gateName === 'CNOT') {
                            if (qubits.length !== 2) throw new Error('CNOT requires 2 qubit indices (control, target).');
                            gateMatrix = getFullGateMatrix(X, numQubits, qubits[1], qubits[0]);
                        } else {
                            errors.push(`Error: Unknown gate "${gateName}" in operation: ${op}`);
                            continue;
                        }
                        stateVector = matrixVectorMultiply(gateMatrix, stateVector);
                    } catch (e) {
                        errors.push(`Error processing operation "${op}": ${e.message}`);
                    }
                }
                return { finalStateVector: stateVector, errors };
            };

            const getFullGateMatrix = (baseGate, numQubits, targetQubit, controlQubit = null) => {
                let fullGate = identityMatrix(1);
                
                for (let i = 0; i < numQubits; i++) {
                    if (i === targetQubit) {
                        fullGate = kroneckerProduct(fullGate, baseGate);
                    } else if (controlQubit !== null && i === controlQubit) {
                        fullGate = kroneckerProduct(fullGate, identityMatrix(2));
                    } else {
                        fullGate = kroneckerProduct(fullGate, identityMatrix(2));
                    }
                }

                if (controlQubit !== null) {
                    if (baseGate === X) {
                        const size = 2 ** numQubits;
                        const cnotMatrix = identityMatrix(size);
                        for (let i = 0; i < size; i++) {
                            if (((i >> (numQubits - 1 - controlQubit)) & 1) === 1) {
                                const flippedI = i ^ (1 << (numQubits - 1 - targetQubit));
                                cnotMatrix[i][i] = new CustomComplex(0, 0);
                                cnotMatrix[i][flippedI] = new CustomComplex(1, 0);
                            }
                        }
                        return cnotMatrix;
                    }
                }
                return fullGate;
            };

            // Partial trace
            const partialTrace = (densityMatrix, numQubits, targetQubitIndex) => {
                if (targetQubitIndex < 0 || targetQubitIndex >= numQubits) {
                    throw new Error("Target qubit index out of bounds for partial trace.");
                }

                const reducedDensityMatrix = Array(2).fill(0).map(() => Array(2).fill(0).map(() => new CustomComplex(0, 0)));
                const otherQubitsCount = numQubits - 1;

                for (let row_q = 0; row_q < 2; row_q++) {
                    for (let col_q = 0; col_q < 2; col_q++) {
                        let sumVal = new CustomComplex(0, 0);

                        for (let other_q_state_int = 0; other_q_state_int < (2 ** otherQubitsCount); other_q_state_int++) {
                            let bra_full_idx = 0;
                            let ket_full_idx = 0;
                            
                            let currentOtherQubitBit = 0;
                            for (let bitPos = 0; bitPos < numQubits; bitPos++) {
                                if (bitPos === targetQubitIndex) {
                                    bra_full_idx |= (row_q << (numQubits - 1 - bitPos));
                                    ket_full_idx |= (col_q << (numQubits - 1 - bitPos));
                                } else {
                                    const bit = (other_q_state_int >> (otherQubitsCount - 1 - currentOtherQubitBit)) & 1;
                                    bra_full_idx |= (bit << (numQubits - 1 - bitPos));
                                    ket_full_idx |= (bit << (numQubits - 1 - bitPos));
                                    currentOtherQubitBit++;
                                }
                            }
                            sumVal = sumVal.add(densityMatrix[bra_full_idx][ket_full_idx]);
                        }
                        reducedDensityMatrix[row_q][col_q] = sumVal;
                    }
                }
                return reducedDensityMatrix;
            };

            const runSimulation = () => {
                setLoading(true);
                setErrorMessage('');
                setBlochVectors([]);

                try {
                    const operations = circuitInput.split('\n').filter(line => line.trim() !== '');
                    const { finalStateVector, errors } = simulateCircuit(numQubits, operations);

                    if (errors.length > 0) {
                        setErrorMessage(errors.join('\n'));
                        setLoading(false);
                        return;
                    }

                    // Calculate overall density matrix
                    const densityMatrix = outerProduct(finalStateVector, finalStateVector);

                    const calculatedBlochVectors = [];
                    for (let i = 0; i < numQubits; i++) {
                        const reducedRho = partialTrace(densityMatrix, numQubits, i);

                        const rho00 = reducedRho[0][0];
                        const rho01 = reducedRho[0][1];
                        const rho10 = reducedRho[1][0];
                        const rho11 = reducedRho[1][1];

                        const rx = rho01.add(rho10).re;
                        const ry = rho01.sub(rho10).im;
                        const rz = rho00.sub(rho11).re;

                        calculatedBlochVectors.push([rx, ry, rz]);
                    }
                    setBlochVectors(calculatedBlochVectors);

                } catch (e) {
                    setErrorMessage(`An unexpected error occurred: ${e.message}`);
                    console.error(e);
                } finally {
                    setLoading(false);
                }
            };

            // Initialize with a default simulation on mount
            React.useEffect(() => {
                runSimulation();
            }, []);

            return (
                <div className="quantum-container text-white p-4">
                    <header className="text-center mb-8">
                        <h1 className="text-4xl font-extrabold text-blue-400 mb-2">
                            Advanced Quantum Bloch Visualizer
                        </h1>
                        <p className="text-lg text-gray-300">
                            Multi-Qubit Circuit Simulation with 3D Bloch Sphere Visualization
                        </p>
                    </header>

                    <div className="max-w-4xl mx-auto bg-gray-800 rounded-xl shadow-2xl p-6 mb-8 border border-blue-600">
                        <div className="mb-6">
                            <label htmlFor="numQubits" className="block text-lg font-medium text-gray-200 mb-2">
                                Number of Qubits:
                            </label>
                            <input
                                type="number"
                                id="numQubits"
                                value={numQubits}
                                onChange={(e) => setNumQubits(Math.max(1, parseInt(e.target.value) || 1))}
                                min="1"
                                max="5"
                                className="input-field w-full p-3 rounded-lg text-lg text-white"
                            />
                            <p className="text-sm text-gray-400 mt-1">
                                (Recommended: 1 to 5 qubits for reasonable performance)
                            </p>
                        </div>

                        <div className="mb-6">
                            <label htmlFor="circuitInput" className="block text-lg font-medium text-gray-200 mb-2">
                                Circuit Operations:
                            </label>
                            <textarea
                                id="circuitInput"
                                value={circuitInput}
                                onChange={(e) => setCircuitInput(e.target.value)}
                                rows="8"
                                className="input-field w-full p-3 rounded-lg text-lg font-mono resize-y text-white"
                                placeholder="e.g.,
H 0
CNOT 0 1
X 2"
                            ></textarea>
                            <p className="text-sm text-gray-400 mt-1">
                                Each line: GATE_NAME qubit_index [control_qubit_index]
                            </p>
                        </div>

                        <button
                            onClick={runSimulation}
                            className="btn-primary w-full px-6 py-3 text-white font-bold text-lg rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                            disabled={loading}
                        >
                            {loading ? (
                                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            ) : (
                                'Run Simulation'
                            )}
                        </button>

                        {errorMessage && (
                            <div className="mt-6 p-4 bg-red-800 border border-red-600 rounded-lg text-red-200 text-sm font-mono whitespace-pre-wrap">
                                Error:
                                <br />
                                {errorMessage}
                            </div>
                        )}
                    </div>

                    <div className="max-w-6xl mx-auto">
                        <h2 className="text-3xl font-bold text-center text-blue-300 mb-6">Bloch Sphere Visualizations</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {blochVectors.length > 0 ? (
                                blochVectors.map((vec, index) => (
                                    <div key={index} className="bloch-sphere rounded-lg shadow-lg p-4">
                                        <h3 className="text-xl font-semibold text-white mb-2 text-center">Qubit {index}</h3>
                                        <div className="text-center">
                                            <div className="text-sm text-gray-300 mb-2">
                                                Bloch Vector: ({vec[0].toFixed(3)}, {vec[1].toFixed(3)}, {vec[2].toFixed(3)})
                                            </div>
                                            <div className="text-sm text-gray-300">
                                                Magnitude: {Math.sqrt(vec[0]**2 + vec[1]**2 + vec[2]**2).toFixed(3)}
                                            </div>
                                        </div>
                                    </div>
                                ))
                            ) : (
                                <p className="col-span-full text-center text-gray-400 text-lg">
                                    No simulation run or results to display.
                                </p>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<QuantumVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>
